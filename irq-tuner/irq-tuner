#!/bin/sh

set -u

VERSION="1.0"
CONFIG_DIR="/etc/irq-tuner"
CONFIG_FILE="$CONFIG_DIR/irq-tuner.conf"
STATE_DIR="$CONFIG_DIR/state.d"
SYSCTL_CONF="/etc/sysctl.d/99-irq-tuner.conf"

msg() { [ "${QUIET:-0}" -eq 1 ] || echo "$@"; }
err() { echo "错误: $*" >&2; }

cpu_count() {
  if [ -r /proc/cpuinfo ]; then
    grep -c '^processor' /proc/cpuinfo 2>/dev/null
  else
    echo 1
  fi
}

cpu_mask_all() {
  count="$(cpu_count)"
  mask=0
  i=0
  while [ "$i" -lt "$count" ] && [ "$i" -lt 63 ]; do
    mask=$((mask | (1 << i)))
    i=$((i + 1))
  done
  printf '%x' "$mask"
}

list_ifaces() {
  if [ -d /sys/class/net ]; then
    ls /sys/class/net | grep -E '^eth[0-9]+' | xargs
  fi
}

default_ifaces() {
  if [ -e /sys/class/net/eth1 ] && [ -e /sys/class/net/eth2 ]; then
    echo "eth1 eth2"
  else
    list_ifaces
  fi
}

write_sysctl_conf() {
  [ -d /etc/sysctl.d ] || return 0
  [ -n "${RPS_SOCK_FLOW_ENTRIES:-}" ] || return 0
  {
    echo "# Generated by irq-tuner"
    echo "net.core.rps_sock_flow_entries=$RPS_SOCK_FLOW_ENTRIES"
  } > "$SYSCTL_CONF"
}

init_config() {
  mkdir -p "$CONFIG_DIR" 2>/dev/null
  if [ ! -f "$CONFIG_FILE" ]; then
    cpus="$(cpu_count)"
    combined="$cpus"
    if [ "$combined" -gt 4 ]; then
      combined=4
    fi
    ifaces="$(default_ifaces)"
    rps_mask="$(cpu_mask_all)"
    rps_sock=$((cpus * 8192))
    if [ "$rps_sock" -lt 16384 ]; then
      rps_sock=16384
    fi
    cat > "$CONFIG_FILE" <<EOF
ENABLE=1
IFACES="$ifaces"
COMBINED="$combined"
RPS_ENABLE=1
RPS_CPUS="$rps_mask"
RPS_FLOW_CNT="4096"
RPS_SOCK_FLOW_ENTRIES="$rps_sock"
XPS_MODE="rr"
IRQ_MODE="rr"
EOF
    write_sysctl_conf
  fi
}

load_config() {
  init_config
  # shellcheck disable=SC1090
  . "$CONFIG_FILE"
  ENABLE="${ENABLE:-1}"
  IFACES="${IFACES:-$(default_ifaces)}"
  COMBINED="${COMBINED:-2}"
  RPS_ENABLE="${RPS_ENABLE:-1}"
  RPS_CPUS="${RPS_CPUS:-$(cpu_mask_all)}"
  RPS_FLOW_CNT="${RPS_FLOW_CNT:-4096}"
  RPS_SOCK_FLOW_ENTRIES="${RPS_SOCK_FLOW_ENTRIES:-16384}"
  XPS_MODE="${XPS_MODE:-rr}"
  IRQ_MODE="${IRQ_MODE:-rr}"
}

save_config() {
  cat > "$CONFIG_FILE" <<EOF
ENABLE=$ENABLE
IFACES="$IFACES"
COMBINED="$COMBINED"
RPS_ENABLE=$RPS_ENABLE
RPS_CPUS="$RPS_CPUS"
RPS_FLOW_CNT="$RPS_FLOW_CNT"
RPS_SOCK_FLOW_ENTRIES="$RPS_SOCK_FLOW_ENTRIES"
XPS_MODE="$XPS_MODE"
IRQ_MODE="$IRQ_MODE"
EOF
  write_sysctl_conf
}

set_sysctl() {
  key="$1"
  val="$2"
  if command -v sysctl >/dev/null 2>&1; then
    sysctl -w "$key=$val" >/dev/null 2>&1 && return 0
  fi
  path="/proc/sys/$(echo "$key" | tr '.' '/')"
  [ -w "$path" ] && echo "$val" > "$path"
}

get_combined_current() {
  iface="$1"
  ethtool -l "$iface" 2>/dev/null | awk '
    /Current hardware settings:/ {found=1; next}
    found && /Combined:/ {print $2; exit}
  '
}

get_irqs_for_iface() {
  iface="$1"
  irqs="$(grep -F " ${iface}-fp-" /proc/interrupts 2>/dev/null | awk '{gsub(":","",$1); print $1}')"
  if [ -z "$irqs" ]; then
    irqs="$(grep -E "[[:space:]]${iface}($|[^-])" /proc/interrupts 2>/dev/null | awk '{gsub(":","",$1); print $1}')"
  fi
  echo "$irqs"
}

ensure_state_dir() {
  mkdir -p "$STATE_DIR" 2>/dev/null
}

save_baseline_once() {
  ensure_state_dir
  if [ -f "$STATE_DIR/.baseline_saved" ]; then
    return 0
  fi
  : > "$STATE_DIR/restore.list"
  : > "$STATE_DIR/baseline.env"
  if command -v sysctl >/dev/null 2>&1; then
    sysctl -n net.core.rps_sock_flow_entries 2>/dev/null > "$STATE_DIR/sysctl_rps_sock_flow_entries"
  else
    cat /proc/sys/net/core/rps_sock_flow_entries 2>/dev/null > "$STATE_DIR/sysctl_rps_sock_flow_entries"
  fi
  for iface in $IFACES; do
    if [ -d "/sys/class/net/$iface" ]; then
      combined="$(get_combined_current "$iface")"
      if [ -n "$combined" ]; then
        echo "COMBINED_${iface}=$combined" >> "$STATE_DIR/baseline.env"
      fi
      for path in /sys/class/net/"$iface"/queues/rx-*/rps_cpus \
                  /sys/class/net/"$iface"/queues/rx-*/rps_flow_cnt \
                  /sys/class/net/"$iface"/queues/tx-*/xps_cpus; do
        [ -r "$path" ] || continue
        val="$(cat "$path" 2>/dev/null)"
        echo "$path=$val" >> "$STATE_DIR/restore.list"
      done
      for irq in $(get_irqs_for_iface "$iface"); do
        path="/proc/irq/$irq/smp_affinity_list"
        [ -r "$path" ] || continue
        val="$(cat "$path" 2>/dev/null)"
        echo "$path=$val" >> "$STATE_DIR/restore.list"
      done
    fi
  done
  echo "BASELINE_SAVED=1" > "$STATE_DIR/.baseline_saved"
}

restore_baseline() {
  load_config
  if [ ! -f "$STATE_DIR/.baseline_saved" ]; then
    err "未找到基线状态."
    return 1
  fi
  if [ -f "$STATE_DIR/sysctl_rps_sock_flow_entries" ]; then
    val="$(cat "$STATE_DIR/sysctl_rps_sock_flow_entries" 2>/dev/null)"
    [ -n "$val" ] && set_sysctl net.core.rps_sock_flow_entries "$val"
  fi
  if [ -f "$STATE_DIR/baseline.env" ]; then
    # shellcheck disable=SC1090
    . "$STATE_DIR/baseline.env"
    for iface in $IFACES; do
      eval "val=\${COMBINED_${iface}:-}"
      if [ -n "$val" ] && command -v ethtool >/dev/null 2>&1; then
        ethtool -L "$iface" combined "$val" >/dev/null 2>&1
      fi
    done
  fi
  if [ -f "$STATE_DIR/restore.list" ]; then
    while IFS='=' read -r path val; do
      [ -n "$path" ] || continue
      [ -w "$path" ] || continue
      echo "$val" > "$path" 2>/dev/null
    done < "$STATE_DIR/restore.list"
  fi
  msg "基线已恢复."
}

apply_rps_xps() {
  iface="$1"
  if [ "$RPS_ENABLE" -eq 1 ]; then
    rps_cpus="$RPS_CPUS"
    rps_flow="$RPS_FLOW_CNT"
  else
    rps_cpus="0"
    rps_flow="0"
  fi

  # Write rps_cpus with retry logic
  for path in /sys/class/net/"$iface"/queues/rx-*/rps_cpus; do
    [ -e "$path" ] || continue
    retry=0
    while [ "$retry" -lt 3 ]; do
      if [ -w "$path" ] && echo "$rps_cpus" > "$path" 2>/dev/null; then
        break
      fi
      retry=$((retry + 1))
      [ "$retry" -lt 3 ] && sleep 1
    done
  done

  # Write rps_flow_cnt with retry logic
  for path in /sys/class/net/"$iface"/queues/rx-*/rps_flow_cnt; do
    [ -e "$path" ] || continue
    retry=0
    while [ "$retry" -lt 3 ]; do
      if [ -w "$path" ] && echo "$rps_flow" > "$path" 2>/dev/null; then
        break
      fi
      retry=$((retry + 1))
      [ "$retry" -lt 3 ] && sleep 1
    done
  done

  if [ "$XPS_MODE" = "off" ]; then
    for path in /sys/class/net/"$iface"/queues/tx-*/xps_cpus; do
      [ -w "$path" ] || continue
      echo 0 > "$path" 2>/dev/null
    done
    return 0
  fi

  cpu_total="$(cpu_count)"
  all_mask="$(cpu_mask_all)"
  i=0
  for path in /sys/class/net/"$iface"/queues/tx-*/xps_cpus; do
    [ -w "$path" ] || continue
    if [ "$XPS_MODE" = "all" ]; then
      echo "$all_mask" > "$path" 2>/dev/null
    else
      cpu=$((i % cpu_total))
      mask=$((1 << cpu))
      printf '%x' "$mask" > "$path" 2>/dev/null
      i=$((i + 1))
    fi
  done
}

apply_irq_affinity() {
  iface_filter="${1:-}"
  [ "$IRQ_MODE" = "none" ] && return 0
  cpu_total="$(cpu_count)"
  all_list="0-$((cpu_total - 1))"
  idx=0
  if [ -n "$iface_filter" ]; then
    iface_list="$iface_filter"
  else
    iface_list="$IFACES"
  fi
  for iface in $iface_list; do
    for irq in $(get_irqs_for_iface "$iface"); do
      path="/proc/irq/$irq/smp_affinity_list"
      [ -w "$path" ] || continue
      if [ "$IRQ_MODE" = "all" ]; then
        echo "$all_list" > "$path" 2>/dev/null
      else
        cpu=$((idx % cpu_total))
        echo "$cpu" > "$path" 2>/dev/null
        idx=$((idx + 1))
      fi
    done
  done
}

apply_tuning() {
  iface_only=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --quiet) QUIET=1 ;;
      --iface) shift; iface_only="${1:-}" ;;
      --with-detect) WITH_DETECT=1 ;;
    esac
    shift
  done
  load_config
  [ "$ENABLE" -eq 1 ] || return 0
  if [ "${WITH_DETECT:-0}" -eq 1 ]; then
    detect_status
  fi
  save_baseline_once
  set_sysctl net.core.rps_sock_flow_entries "$RPS_SOCK_FLOW_ENTRIES"

  # Verify sysctl took effect
  actual=$(cat /proc/sys/net/core/rps_sock_flow_entries 2>/dev/null)
  if [ "$actual" != "$RPS_SOCK_FLOW_ENTRIES" ]; then
    # Retry if verification failed
    set_sysctl net.core.rps_sock_flow_entries "$RPS_SOCK_FLOW_ENTRIES"
  fi

  for iface in $IFACES; do
    [ -d "/sys/class/net/$iface" ] || continue
    [ -n "$iface_only" ] && [ "$iface" != "$iface_only" ] && continue
    if command -v ethtool >/dev/null 2>&1; then
      ethtool -L "$iface" combined "$COMBINED" >/dev/null 2>&1
      # Wait for driver to process queue reconfiguration
      sleep 1
    fi
    apply_rps_xps "$iface"
  done
  apply_irq_affinity "$iface_only"
  if [ "${WITH_DETECT:-0}" -eq 1 ]; then
    detect_status
  fi
}

detect_status() {
  load_config
  msg "irq-tuner 状态 (v$VERSION)"
  msg "接口: $IFACES"
  msg "队列(COMBINED): $COMBINED"
  msg "RPS_ENABLE: $RPS_ENABLE RPS_CPUS: $RPS_CPUS RPS_FLOW_CNT: $RPS_FLOW_CNT"
  msg "RPS_SOCK_FLOW_ENTRIES: $RPS_SOCK_FLOW_ENTRIES"
  msg "XPS_MODE: $XPS_MODE IRQ_MODE: $IRQ_MODE"
  if command -v sysctl >/dev/null 2>&1; then
    msg "sysctl rps_sock_flow_entries: $(sysctl -n net.core.rps_sock_flow_entries 2>/dev/null)"
  fi
  for iface in $IFACES; do
    [ -d "/sys/class/net/$iface" ] || continue
    msg "接口: $iface"
    if command -v ethtool >/dev/null 2>&1; then
      msg "  当前 combined: $(get_combined_current "$iface")"
      ethtool -x "$iface" 2>/dev/null | head -n 4 | sed 's/^/  /'
    fi
    for irq in $(get_irqs_for_iface "$iface"); do
      val="$(cat /proc/irq/"$irq"/smp_affinity_list 2>/dev/null)"
      msg "  irq $irq 亲和性: $val"
    done
    for path in /sys/class/net/"$iface"/queues/rx-*/rps_cpus; do
      [ -r "$path" ] || continue
      msg "  $(basename "$path") rps_cpus: $(cat "$path" 2>/dev/null)"
    done
    for path in /sys/class/net/"$iface"/queues/rx-*/rps_flow_cnt; do
      [ -r "$path" ] || continue
      msg "  $(basename "$path") rps_flow_cnt: $(cat "$path" 2>/dev/null)"
    done
    for path in /sys/class/net/"$iface"/queues/tx-*/xps_cpus; do
      [ -r "$path" ] || continue
      msg "  $(basename "$path") xps_cpus: $(cat "$path" 2>/dev/null)"
    done
  done
  msg "softnet_stat (丢包/拥塞):"
  i=0
  while read -r col1 col2 col3 _; do
    drops=$((0x$col2))
    tsq=$((0x$col3))
    msg "  CPU$i 丢包=$drops time_squeeze=$tsq"
    i=$((i + 1))
  done < /proc/net/softnet_stat
  msg "interrupts (过滤):"
  pattern="$(echo "$IFACES" | tr ' ' '|')"
  if [ -n "$pattern" ]; then
    grep -E "$pattern" /proc/interrupts 2>/dev/null | sed 's/^/  /'
  fi
}

configure_menu() {
  load_config
  msg "配置参数 (回车保留当前值)"
  printf "IFACES [%s]: " "$IFACES"
  read -r input
  [ -n "$input" ] && IFACES="$input"

  printf "COMBINED [%s]: " "$COMBINED"
  read -r input
  [ -n "$input" ] && COMBINED="$input"

  printf "RPS_ENABLE (1/0) [%s]: " "$RPS_ENABLE"
  read -r input
  [ -n "$input" ] && RPS_ENABLE="$input"

  printf "RPS_CPUS hex mask or 'auto' [%s]: " "$RPS_CPUS"
  read -r input
  if [ -n "$input" ]; then
    if [ "$input" = "auto" ]; then
      RPS_CPUS="$(cpu_mask_all)"
    else
      RPS_CPUS="$input"
    fi
  fi

  printf "RPS_FLOW_CNT [%s]: " "$RPS_FLOW_CNT"
  read -r input
  [ -n "$input" ] && RPS_FLOW_CNT="$input"

  printf "RPS_SOCK_FLOW_ENTRIES [%s]: " "$RPS_SOCK_FLOW_ENTRIES"
  read -r input
  [ -n "$input" ] && RPS_SOCK_FLOW_ENTRIES="$input"

  printf "XPS_MODE (rr/all/off) [%s]: " "$XPS_MODE"
  read -r input
  [ -n "$input" ] && XPS_MODE="$input"

  printf "IRQ_MODE (rr/all/none) [%s]: " "$IRQ_MODE"
  read -r input
  [ -n "$input" ] && IRQ_MODE="$input"

  save_config
  msg "配置已保存."
}

confirm_apply() {
  msg "当前状态:"
  detect_status
  printf "现在应用调优? [y/N]: "
  read -r ans
  case "$ans" in
    y|Y) return 0 ;;
    *) return 1 ;;
  esac
}

uninstall_all() {
  restore_baseline
  /etc/init.d/irq-tuner stop >/dev/null 2>&1
  /etc/init.d/irq-tuner disable >/dev/null 2>&1

  # Stop and remove watchdog from crontab
  if command -v crontab >/dev/null 2>&1; then
    crontab -l 2>/dev/null | grep -v irq-tuner-watchdog | crontab - 2>/dev/null
  fi

  # Remove all files
  rm -f /etc/init.d/irq-tuner \
        /etc/hotplug.d/iface/99-irq-tuner \
        /etc/sysctl.d/99-irq-tuner.conf \
        /usr/sbin/irq-tuner-watchdog
  rm -rf "$CONFIG_DIR"

  msg "已卸载 irq-tuner（含watchdog）."
  if [ "${PURGE_SELF:-0}" -eq 1 ]; then
    rm -f /usr/sbin/irq-tuner
  fi
}

menu() {
  while :; do
    msg ""
    msg "irq-tuner 菜单"
    msg "1) 检测/监测"
    msg "2) 应用调优 (检测 -> 确认 -> 调优 -> 再检测)"
    msg "3) 配置参数"
    msg "4) 回滚到基线"
    msg "5) 卸载"
    msg "0) 退出"
    printf "选择: "
    read -r choice
    case "$choice" in
      1) detect_status ;;
      2)
        if confirm_apply; then
          apply_tuning --with-detect
        else
          msg "已取消."
        fi
        ;;
      3) configure_menu ;;
      4) restore_baseline ;;
      5)
        printf "确认卸载? [y/N]: "
        read -r ans
        case "$ans" in
          y|Y) PURGE_SELF=1 uninstall_all; return ;;
          *) msg "已取消." ;;
        esac
        ;;
      0) return ;;
      *) msg "无效选择." ;;
    esac
  done
}

usage() {
  cat <<EOF
用法: irq-tuner [menu|status|detect|apply|rollback|configure|uninstall|init]
  menu                 交互菜单 (默认)
  status|detect         显示当前状态
  apply [--iface IF]    应用调优 (非交互)
  rollback              恢复保存的基线
  configure             交互编辑配置
  uninstall             回滚并移除服务/配置
  init                  仅初始化配置
EOF
}

cmd="${1:-menu}"
shift || true

case "$cmd" in
  menu) menu ;;
  status|detect) detect_status ;;
  apply) apply_tuning "$@" ;;
  rollback) restore_baseline ;;
  configure) configure_menu ;;
  uninstall) PURGE_SELF=1 uninstall_all ;;
  init) init_config ;;
  *) usage ;;
esac
